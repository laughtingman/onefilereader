<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>FB2 reader</title>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.9/vue.min.js' integrity='sha512-deBbW1lpMT6h3gvOzmeMPft4pf9CMGjCKc5jSNq2pMSjtkMPuELbd4N3LKXVq/t1t6qco4q3u/XguyqGqlOMjA==' crossorigin='anonymous'></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/jszip/3.5.0/jszip.min.js' integrity='sha512-y3o0Z5TJF1UsKjs/jS2CDkeHN538bWsftxO9nctODL5W40nyXIbs0Pgyu7//icrQY9m6475gLaVr39i/uh/nLA==' crossorigin='anonymous'></script>

	<style>
		.panel {
			position: fixed;
			top: 0;
			left: -16rem;
			font-family: Verdana, Geneva, Tahoma, sans-serif;
			background-color: #fafafa;
			height: 100vh;
			width: 16rem;
			font-size: 1rem;
			transition-property: left;
			transition-duration: 0.5s;
		}

		.panel .scroll {
			box-sizing: border-box;
			padding: 0.5rem;
			overflow-y: scroll;
			overflow-x: hidden;
			width: 100%;
			height: 100%;
		}

		.panel a {
			color: gray;
			display: block;
			margin: 0.3rem 0;
		}

		.panel:after {
			content: "\00A7";
			display: block;
			position: absolute;
			top: 0;
			left: 100%;
			height: 100%;
			width: 1.5rem;
			text-align: center;
		}

		.panel:hover {
			left: 0;
		}

		.panel:hover:after {
			content: "";
		}



		.panel .group {
			margin: 1rem 0;
			color: black;
		}

		.panel label {
			display: flex;
			margin: 0.3rem 0;
			color: black;
		}

		.panel label span {
			width: 100%;
			display: block;
			margin-right: 0.2rem;
		}

		button,
		select,
		input {
			font-size: 1em;
			width: 100%;
		}

		body {
			font-size: 16px;
			margin: 0;
			padding: 0;
		}

		.book {
			min-height: 100vh;
		}

		.page {
			max-width: 40em;
			margin: 0 auto;
			padding-top: 2em;
		}

		p {
			font-size: 1em;
			line-height: 1.5em;
			margin: 1em 0;
			text-align: justify;
		}

		img {
			display: block;
			margin: 0 auto;
			max-width: 100%;
			height: auto;
		}

		.title {
			font-weight: bold;
			margin: 2em 0 1rem 0;
		}

		.title p {
			font-size: 2em;
		}

		.title p+p {
			font-size: 1.5em;
		}

		.subtitle {
			text-align: center;
		}

		.epigraph {
			max-width: 60%;
			margin-left: auto;
		}

		blockquote {
			border-left: 0.4em solid black;
			padding-left: 1em;
			margin: 1em 0;
		}

		.scroll::-webkit-scrollbar {
			width: 0.4rem;
		}

		.scroll::-webkit-scrollbar-track {
			background: #eee;
		}

		.scroll::-webkit-scrollbar-thumb {
			background-color: #ccc; 
			border-radius: 20px;
		}

		body::-webkit-scrollbar, .notes::-webkit-scrollbar {
			width: 0.4rem;
		}

		body::-webkit-scrollbar-thumb, .notes::-webkit-scrollbar-thumb { 
			border-radius: 20px;
		}

		.notes {
			position: fixed;
			max-width: 40em;
			height: 30vh;
			left: 0;
			right: 0;
			bottom: -31vh;
			overflow-y: scroll;
			margin: 0 auto;
			transition-property: bottom;
			transition-duration: 0.5s;
		}

		.notes.show {
			bottom: 0;
		}

		.notes .title {
			margin: 1em 0;
		}

		.notes .title p {
			font-size: 1em;
		}
	</style>
</head>

<body>
	<div id="app">
		<div class="book" :style="style">
			<div class="panel">
				<div class="scroll">
					<div class="group">
						<button class="btn" @click="open">Открыть</button>
					</div>
					<div class="group">
						<img :src="book.cover">
					</div>
					<div class="group">
						<div>{{book.author.firstName}} {{book.author.lastName}}</div>
						<div><b>{{book.title}}</b></div>
					</div>

					<div class="group">
						<label><span>Текст:</span><input type="color" v-model="options.color"></label>
						<label><span>Фон:</span><input type="color" v-model="options.background"></label>
						<label><span>Ссылки:</span><input type="color" v-model="options.links"></label>
					</div>
					<div class="group">
						<a href="#" data-color="#000000" data-background="#FFFFFF" data-links="#00AAFF" @click.prevent="theme">Черный на белом</a>
						<a href="#" data-color="#5bae67" data-background="#111111" data-links="#8cae5b" @click.prevent="theme">Зелёный на сером</a>
					</div>
					<div class="group">
						<label><span>Шрифт:</span>
							<select v-model="options.fontFamily">
								<option value="Verdana">Verdana</option>
								<option value="Georgia">Georgia</option>
								<option value="Times">Tlmes</option>
							</select>
						</label>
						<label><span>Размер:</span>
							<select v-model.number="options.fontSize">
								<option value="12">12</option>
								<option value="14">14</option>
								<option value="16">16</option>
								<option value="18">18</option>
								<option value="24">24</option>
							</select>
						</label>
					</div>
				</div>
			</div>
			<div v-html="book.main" class="page"></div>
			<div v-html="book.notes" class="notes" :class="{show:showNotes}"></div>
			<div v-html="moreStyles"></div>
		</div>
	</div>

	<script>
		var app = new Vue({
			el: "#app",
			data: {
				xml: null,
				showNotes: false,
				book: {
					title: "",
					author: {},
					cover: "",
					main: "",
					notes: "",
					hash: ""
				},
				options: {
					fontSize: 16,
					color: "#000000",
					background: "#FFFFFF",
					links: "#00AAFF",
					fontFamily: "Verdana",
				}
			},
			mounted() {
				if (localStorage['fb2Reader_book']) {
					this.book = JSON.parse(localStorage['fb2Reader_book']);
				}

				if (localStorage['fb2Reader_options']) {
					this.options = JSON.parse(localStorage['fb2Reader_options']);
				}

				this.restoreProgress();
			},
			updated() {
				localStorage.setItem("fb2Reader_options", JSON.stringify(this.options));
			},
			methods: {

				open() {
					function error() {
						alert("File not supported!");
					}
					let that = this;
					let div = document.createElement('div');
					div.innerHTML = '<input type="file" accept=".fb2,.fb2.zip">';
					let fileInput = div.firstChild;
					fileInput.addEventListener('change', function() {
						let file = fileInput.files[0];
						if (file.name.match(/\.(fb2)$/)) {
							
							let reader = new FileReader();
							reader.onload = function() {
								that.parse(reader.result);
								div.remove();
							}
							reader.readAsArrayBuffer(file);

						} else if (file.name.match(/\.fb2\.zip$/)) {

							JSZip.loadAsync(file).then(function(zip) {

								let file = zip.file(/\.fb2$/);
								if (file[0] != undefined) {
									file[0].async("arraybuffer").then(function (result) {
											that.parse(result);
										});
								} else {
									alert("File not supported!");
								}
							});
						} else {
							error();
							div.remove();
						}
					});
					fileInput.click();
				},
				parse(buffer) {
					let decoder = new TextDecoder();
					let parser = new DOMParser();
					let xml = null,
						text = "";
					try {
						text = decoder.decode(buffer);
						xml = parser.parseFromString(text, "text/xml");
						if (xml.xmlEncoding != 'utf-8') {
							decoder = new TextDecoder(xml.xmlEncoding);
							text = decoder.decode(buffer);
							xml = parser.parseFromString(text, "text/xml");
						}
					} catch {
						alert("Книга повреждена или не поддерживается!");
						return;
					}
					if (xml.getElementsByTagName("FictionBook").length == 0) {
						alert("Формат книги не поддерживается!");
						return;
					}

					this.xml = xml;

					let title = this.nodeText(xml.getElementsByTagName("book-title")[0]);

					this.book.title = title;
					this.book.hash = this.hashCode(title);

					let author = xml.getElementsByTagName("author")[0];
					if (author != null) {
						this.book.author.firstName = this.nodeText(author.getElementsByTagName("first-name")[0]);
						this.book.author.lastName = this.nodeText(author.getElementsByTagName("last-name")[0]);
						this.book.author.nickName = this.nodeText(author.getElementsByTagName("nick-name")[0]);
					}

					this.book.cover = "";

					let coverpage = xml.getElementsByTagName("coverpage")[0];
					if (coverpage !=null) {
						let cover = coverpage.getElementsByTagName("image")[0];
						if (cover != null) {
							let id = cover.getAttribute("l:href") || cover.getAttribute("xlink:href");
							id = id.replace(/#/g, '');
							let binary = xml.getElementById(id);
							if (binary != null) {
								let type = binary.getAttribute("content-type");
								let base64 = binary.childNodes[0].nodeValue;
								this.book.cover = `data:${type};base64, ${base64}`;
							}
						}
					}

					let bodys = xml.getElementsByTagName("body");
					let output = "";

					for (let body of bodys) {
						output += this.parseNode(body);
					}

					this.book.main = "";
					this.book.notes = "";

					for (let i=0; i<bodys.length; i++) {
						if (i==0) {
							this.book.main = this.parseNode(bodys[i]);
						} else {
							this.book.notes += this.parseNode(bodys[i]);
						}
					}

					localStorage.setItem("fb2Reader_book", JSON.stringify(this.book));
					this.restoreProgress();
				},
				parseNode(node) {
					output = "";

					if (node.nodeType == 1) {

						let that = this;
						let tags = {
							body: {
								start(node) {
									return "<div class='body'>"
								},
								end: "</div>"
							},
							section: {
								start(node) {
									let id = node.getAttribute("id");
									return id != undefined ? `<section id='${id}'>` : "<section>";
								},
								end: "</section>"
							},
							p: {
								start(node) {
									return "<p>"
								},
								end: "</p>"
							},
							title: {
								start(node) {
									return "<div class='title'>"
								},
								end: "</div>"
							},
							subtitle: {
								start(node) {
									return "<div class='subtitle'>"
								},
								end: "</div>"
							},
							"empty-line": {
								start(node) {
									return "<div class='line'>"
								},
								end: "</div>"
							},
							emphasis: {
								start(node) {
									return "<em>"
								},
								end: "</em>"
							},
							strong: {
								start(node) {
									return "<b>"
								},
								end: "</b>"
							},
							epigraph: {
								start(node) {
									return "<div class='epigraph'>"
								},
								end: "</div>"
							},
							cite: {
								start(node) {
									return "<blockquote>"
								},
								end: "</blockquote>"
							},
							"text-author": {
								start(node) {
									return "<cite>"
								},
								end: "</cite>"
							},
							date: {
								start(node) {
									return "<date>"
								},
								end: "</date>"
							},
							poem: {
								start(node) {
									return "<div class='poem'>"
								},
								end: "</div>"
							},
							stanza: {
								start(node) {
									return "<div class='stanza'>"
								},
								end: "</div>"
							},
							v: {
								start(node) {
									return "<p>"
								},
								end: "</p>"
							},
							image: {
								start(node) {

									let id = node.getAttribute("l:href") || node.getAttribute("xlink:href");
									id = id.replace(/#/g, '');
									let binary = that.xml.getElementById(id);
									if (binary != null) {
										let type = binary.getAttribute("content-type");
										let base64 = binary.childNodes[0].nodeValue;
										return `<img src="data:${type};base64,${base64}">`
									} else {
										return "";
									}
								},
								end: ""
							},
							a: {
								start(node) {
									let href = node.getAttribute("l:href") || node.getAttribute("xlink:href");
									let text = node.childNodes[0].nodeValue;
									return `<a href='${href}'>${text}</a>`
								},
								end: ""
							},
							link: {
								start(node) {
									let href = node.getAttribute("l:href") || node.getAttribute("xlink:href");
									let text = node.childNodes[0].nodeValue;
									return `<a href='${href}'>${text}</a>`
								},
								end: ""
							}
						}

						if (tags[node.nodeName] != undefined) {

							output += tags[node.nodeName].start(node);
							let end = tags[node.nodeName].end;

							if (end != "") {
								for (let childNode of node.childNodes) {
									output += this.parseNode(childNode);
								}
								output += end;
							}
						}

					} else if (node.nodeType == 3) {
						let text = node.nodeValue;
						text = text.replace(/(\s)(\S+)$/gm, "&nbsp;$2");
						text = text.replace(/(\s\S{1,3})(\s)(\S+)/gm, "$1&nbsp;$3");
						text = text.replace(/(\d)(\s)(\S+)/gm, "$1&nbsp;$3");
						text = text.replace(/(\s)(—)/gm, "&nbsp;$2");
						output += text;
					}

					return output;
				},
				theme(event) {
					let theme = event.target.dataset;
					this.options.color = theme.color;
					this.options.background = theme.background;
					this.options.links = theme.links;
				},
				hashCode(s) {
					return s.split("").reduce(function(a, b) {
						a = ((a << 5) - a) + b.charCodeAt(0);
						return a & a
					}, 0);
				},
				restoreProgress() {
					if (localStorage["fb2Reader_scroll" + this.book.hash]) {
						let i = localStorage.getItem("fb2Reader_scroll" + this.book.hash);
						this.$nextTick(function() {
							setTimeout(() => {
								let p = document.getElementsByTagName('p');
								if (p.length > i) {
									let scroll = p[i].offsetTop;
									window.scrollTo(0, scroll);
								}
							}, 500);
						});
					}
				},
				nodeText(node) {
					if (node != null && node != undefined && node.childNodes.length>0) {
						return node.childNodes[0].nodeValue;
					} else {
						return "";
					}
				}
			},
			computed: {
				style() {
					return {
						fontSize: this.options.fontSize + "px",
						fontFamily: this.options.fontFamily,
						color: this.options.color,
						background: this.options.background
					}
				},
				moreStyles() {
					return `<style>
						a {
							color: ${this.options.links}
						}
						.page *::selection, .notes *::selection {
							background-color: ${this.options.color};
							color: ${this.options.background};
						}

						blockquote {
							border-left: 0.4em solid ${this.options.color};
						}

						body::-webkit-scrollbar-track, .notes::-webkit-scrollbar-track {
							background: ${this.options.background};
						}

						body::-webkit-scrollbar-thumb, .notes::-webkit-scrollbar-thumb {
							background-color: ${this.options.color}; 
						}

						.notes {
							border-top: 1px solid ${this.options.color};
							background-color: ${this.options.background};
						}
						</style>`;
				}
			}
		});

		window.addEventListener('scroll', function(e) {
			app.showNotes = false;
			history.pushState(null, null, ' ');
			let p = document.getElementsByTagName('p');
			let wt = window.pageYOffset || document.documentElement.scrollTop;
			for (var i = 0; i < p.length; i++) {
				let bt = p[i].offsetTop,
					bb = bt + p[i].offsetHeight;
				if (bt < wt && bb >= wt) {
					localStorage.setItem("fb2Reader_scroll" + app.book.hash, i);
					return true;
				}
			}
		});

		window.addEventListener("hashchange", function(){
			app.showNotes = true;
		});
	</script>
</body>

</html>